# Kinda long docstring.
# You may need to disable soft wrap to see it clearly.
# If you've seen it already in  readme.MD  you may want to scroll down to the line 156 for the code
it_is_amplifying_audio_but_not_those_loudly_parts = """




■ it change this: ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■




························································································································

                                                                                             ## ####                    
                              #                                                           ###  #   ##                   
                            ####                                                         #          #                   
                          ####  #                                                       ##          ##                  
    ###                   #     ##                                               ##    ##            #                  
   ## #                  #       #                                            # ## #####             ##                 
···#··##·················#·······##·············T·H·R·E·S·H·O·L·D············###······················#·················
  ##   ##               #         #                                          #                        #                 
 ##     ###             #          #                                        ##                        ##                
 #       ###   ##      ##          ##                  ####                 #                          #                
#··········##·###·····##············##················#···##···············##··························#####············
#            ## ##  ###              #              ###    ##       ##     #                                ###   ####  
                 # #                 ##            ##        #  #######  ##                                    ###   #  
                 ###                  ####         #         ####     ####                                            # 
··················#·······················#·······##································T·H·R·E·S·H·O·L·D··················#
                                          ##      #                                                                     
                                           #     ##                                                                     
                                           #   ###                                                                      
                                            # ###                                                                       
                                            ###                                                                         
                                            #                                                                           

························································································································




■ by this: ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■




························································································································

                                                                                             ·· ····                    
                              ·                                                           ···  ·   ··                   
                            ····                                                         ·          ·                   
                          ····  ·                                                       ··          ··                  
    ···                   ·     ··                                               ··    ··            ·                  
   ·· ·                  ·       ·                                            · ·· ·····             ··                 
·····#························##·····························································#######····················
  ·## #··               · ####  ##·                                          ·           ###        ##·                 
 ··#   ##··             ·#       ##·                                        ··###########            ##·                
 ##     ###·   ##      ·#         ##·                  ####                 ·#                        ##                
##·········##·###·····##············##···············##···##···············##··························#####············
#            ## ##  ###              #####         ##··    ##       ##     #                                ###   ####  
                 # #                 ··   ##      #··        #  #######  ##                                    ###   #  
                 ###                  ···· ## #### ·         ####     ####                                            # 
··················#·························###········································································#
                                          ··      ·                                                                     
                                           ·     ··                                                                     
                                           ·   ···                                                                      
                                            · ···                                                                       
                                            ···                                                                         
                                            ·                                                                           

························································································································




■ into this: ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■




·····#························##··································································##····················
    ###                     ####                                                            ########                    
    # #                    ### ##                                                        ####      ##                   
   ## #                   ###   #                                                        #          #                   
   #  ##                 ##     ##                                                      ##          ##                  
   #   #                 ##      #                                               ##    ##            #                  
   #   #                 #       #                                              ## #####             ##                 
  ##   ##               ##       ##                     #                     ###                     #                 
··#·····##··············#·········#····················##····················##·······················#·················
 ##      ##    ##       #          #                   ####                  #                        ##                
 #        #    ##      ##          #                  ##  #                 ##                        ##                
##        ##  ###      #           ##                 #   #                 #                          #                
#··········#··#·#·····##············##················#····#···············##··························##···············
#          #### #    ###             #               ##    #               #                             ###            
#            ## #   ###              #             ###     #               #                                #       #   
             #  #   ###               #            #       ##       ##     #                                 ##   ###   
················##·##·················#####········#········#·······##····##··································#··##·##··
                 # ##                     #       ##        ##   #  ##    #                                   ####   #  
                 # #                      ##      #          #  #### ##  ##                                    ##    #  
                 ###                      ##     ##          #  #     #  ##                                          #  
                 ###                       #     #           ## #     # ##                                           ## 
                 ###                       ##  ###            ###     ###                                             # 
                 ##                         # ###             ##                                                      ##
                  #                         ###                                                                       ##
············································##··········································································




■ avoiding that: ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■




···#####·················#########···········LIMIT·OF·int16·CAPACITY··········#########################·········+32767··
   #···#                ##  ···· ##                                          ##             ········  #                 
   #· ·#                #  ··· ·· #                                          #           ····      ·· #                 
  ##· ·#                # ···   · #                                          #           ·          · #                 
  ##  ·##               #··     ··#                                          #          ··          ··#                 
  #·   ·##              #··      ·##                                         #   ··    ··            ·##                
 ##·   ·###             #·       · #                                        ##  ·· ·····             ·##                
 ##·   ··##             #·       ··#                    #                   ##···                     ·#                
·#·······##·············#··········#···················##···················#··························#················
 #·      ·#    ##      ##          #                   ####                 #·                        ·#                
##        ##   ##      #·          ·#                 ##  #                 #·                        ·#                
#·        ·#  ###      #           ·#                 #   #                 #                          #                
#··········#··#·#·····##············#·················#····#···············##···························#···············
#          #### #    ###            ##               ·#    #               #                             ###            
#            ## #   ###             ##             ··##    #               #                                #       #   
             #  #   ###              #·            · #     ##       ##     #                                 ##   ###   
················##·##················#··············##······#·······##····##··································#··##·##··
                 # #·                #    ·       ·##       ##   #  ##    #                                   ####   #  
                 # #                 ##   ··      ·#         #  #### ##  ##                                    ##    #  
                 ###                  #   ··     ··#         #  #     #  ##                                          #  
                 ###                  #    ·     · #         ## #     # ##                                           ## 
                 ###                  #  # ··  ··· #          #·#     ###                                             # 
                 ##                   ##### · ··· ##          ##                                                      ##
                  #                      ## ···   ##                                                                  ##
··········································##########·························or·some·other·(·like·int16·)··· -32768·····




■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
Works on 16-bit depth wave.
If You want it on other depth   adjust   new_range_for_amplify   to your max bit capacity.

Activate prints to se the process
and / or
plt.show()
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
NOTE: Try it on small audio or big computer! ;) 
"""

import wave, struct
from functools import reduce
from typing import List, Tuple, Any

import sys
import numpy  as np
import pandas as pd
from scipy.io.wavfile import read
import matplotlib.pyplot as plt
from math import inf
from statistics import mean

from get_size__obj_seen_None import get_size



'''
⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋
⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆
#    #    #    #     początek metod     #    #    #    #
⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋⠙⣄⣠⠋
⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆⣰⠏⠹⣆ '''

def deamplify_gently_parts_of_channel_by_threshold(   channel:List[int]
                                                    # , THRESHOLD:int = 20_000
                                                    , **kwargs   ) -> List :

    left = channel

    global THRESHOLD
    # THRESHOLD         =  20_000
    THRESHOLD         =  10_000
    THRESHOLD         =   2_000
    # THRESHOLD         =  0.1
    global ADDITIONAL_OFFSET
    # ADDITIONAL_OFFSET =  THRESHOLD / 20_000
    ADDITIONAL_OFFSET =  0.1
    # ADDITIONAL_OFFSET =  - 29_999.9

    # # plt.figure.set_axis_bgcolor( "black" )
    # # plt.figure( bgcolor=('black') )
    # plt.rcParams['figure.facecolor'] = 'black'
    # plt          .figure(facecolor   = (0, 0, 0)  ) # do the same
    # ''' resets plt '''
    # # plt.figure( facecolor=(0, 0, 1) )
    # plt.rcParams['axes.facecolor'] = 'black'
    # # plt.rcParams['axes.fontcolor'] = 'w'
    # plt.axhline(   y=  THRESHOLD,  xmin=0,xmax=1,   lw=1,   alpha=.6,     label='— THRESHOLD'        )
    # plt.axhline(   y= 0         ,  xmin=0,xmax=1,   lw=1,   alpha= 1,     label='— middle of wave'   )
    # plt.axhline(   y= -THRESHOLD,  xmin=0,xmax=1,   lw=1,   alpha=.6,     label='— THRESHOLD'        )

    plt.axhline(   y=    30_000 ,  xmin=0,xmax=1,   lw=1,   alpha=0.2,   c='black',  label='_nolegend_'                       )
    plt.axhline(   y=  THRESHOLD,  xmin=0,xmax=1,   lw=1,   alpha=0.2,   c='black',  label=f'— THRESHOLD  + {  THRESHOLD }'   )
    plt.axhline(   y= 0         ,  xmin=0,xmax=1,   lw=1,   alpha=0.4,   c='black',  label='— middle of wave'                 )
    plt.axhline(   y= -THRESHOLD,  xmin=0,xmax=1,   lw=1,   alpha=0.2,   c='black',  label=f'— THRESHOLD   – { THRESHOLD }'   )
    plt.axhline(   y=   -30_000 ,  xmin=0,xmax=1,   lw=1,   alpha=0.2,   c='black',  label='_nolegend_'                       )



    left_orig = left.copy()
    # left_for_NaN = left.copy()

    global left_for_NaN
    left_for_NaN = []
    for i in range(   len( left )   ):
        left_for_NaN.append(  None  )


    def scalled(   some_int64,   old_range,   new_range   ):
        print(   type( some_int64 ),   some_int64   )
        new_scalled_int64  =  np.int16(   ( some_int64+0.001 * new_range )  /  old_range    )
        print(   f'    new_scalled_int64: {  new_scalled_int64  }'   )
        return  new_scalled_int64


    print()
    zero_cross_list = time_points_before_zero_crossed =  [ 0, 0, 0 ]
    # for i, number in    enumerate(   channel[:-1]  ):
    for   i    in range(   0,   len( left )-1   ):
        if      left[i] >  0   and   left[i+1] >  0    or \
                left[i] <  0   and   left[i+1] <  0:
            pass
        else:
            zero_cross_list.append( i )
    print(   len( zero_cross_list )   ) # 17
    # print(        zero_cross_list     )
    ''' [0, 5, 52, 103, 148, 182, 228, 276, 321, 347, 352, 356, 399, 452, 494] '''
    # zero_cross_list.append(    3_810_240_000    ) # 24*60*60*44_100        = 3_810_240_000
    # print(   len( zero_cross_list )   ) # 18      # 2**32                  = 4_294_967_296
    # print(        zero_cross_list     )           # 2**64    =  18_446_744_073_709_551_616
    ''' [0, 5, 52, 103, 148, 182, 228, 276, 321, 347, 352, 356, 399, 452, 494, 495, 496, -1]  '''
    '''  IndexError: list index out of range '''
    # zero_cross_list.append(    -1+1    )

    ##### get rid of double values if exist #####
    # if         zero_cross_list[0] == 0  \
    #     and    zero_cross_list[1] == 0  :
    #     zero_cross_list.remove(0)
    # print(      zero_cross_list     )
    zero_cross_list   =   sorted(  list(  set(  zero_cross_list  )  )  )
    print(   len( zero_cross_list )   )
    # print(        zero_cross_list     )
    ''' ValueError: max() arg is an empty sequence '''

    # dict_L   =   dict(   enumerate( left )   )
    # # print( dict_L )
    # print()
    # for i in range( 490, 500 ):
    #     print(   i-490,   dict_L[i],   end='   '   )
    ''' the same effect _ but less memory '''
    # dict_L_part   =   dict(   enumerate( left[   :   ] )   )
    # print(   f' = = = dict_L_part   0, 1, 45, 46  =  { dict_L_part[0] }, { dict_L_part[1] }, { dict_L_part[45] }, { dict_L_part[46] }  '   )
    ''' {0: 11923, 1: 9337, 2: 7001, 3: 4728, 4: 2059, 5: -980, 6: 32767, 7: -32767, 8: -8083, 9: -9951} '''



    global counter
    counter = 1
    periods = periods_over_threshold_list = []
    # for start_p, end_p   in [   *zip(  zero_cross_list[ :-1],  zero_cross_list[1: ]  )   ]:
    # print(                      *zip(  zero_cross_list[ :-1],  zero_cross_list[1: ]  )        )
    '''   (0, 5)     (5, 52)     (52, 103)  (103, 148)  (148, 182)  (182, 228)  (228, 276)  (276, 321)
        (321, 347)  (347, 352)  (352, 356)  (356, 399)  (399, 452)  (452, 494)  (494, 495)  (495, 496)  (496, -1) '''
    for start_end   in             zip(  zero_cross_list[ :-1],  zero_cross_list[1: ]  )    :
        # print(   f'\n{  counter  }\t{  start_end  }      ',   end=''   )
        counter += 1

        p_st,  p_en   =   start_end[0],  start_end[1]
        # print(   f'{         p_st     }  {       p_en     }'   )
        # print(   f'  { left[ p_st   ] }  { left[ p_en+1 ] }'   )
        # print(   f'  { left[ p_st+1 ] }  { left[ p_en   ] }'   )

        ''' avoid empty sequence  # not needed after:     „ =   sorted(  list(  set(  zero_cross_list  )  )  )” '''
        if   p_st+1  !=  p_en+1  :
            per2check =  left[   p_st+1  :  p_en+1  ]
            # print(  per2check  )
            if       abs( max( per2check ) )  >=  THRESHOLD    \
                or   abs( min( per2check ) )  >=  THRESHOLD:

                # temp_list_for_plt = []
                for i in range(  len(left)  ):
                    if i in range(  p_st+1  ,  p_en+1  ):

                        if    max( per2check ) >  0:
                            old_range = max( per2check )
                            new_range =     THRESHOLD - ADDITIONAL_OFFSET

                            # print(   f'no_{ i }   {  left[i]  }  ==>  ',   end=''   )
                            left_for_NaN[i]          = left[i]
                            left[i]  =              ( (left[i]+0.001) * new_range )  /  old_range
                            # print(                   left[i],   '   \t',   type( left[i] )   )

                        if    min( per2check ) <  0:
                            old_range = min( per2check )
                            new_range =  -( THRESHOLD - ADDITIONAL_OFFSET )

                            # print(   f'no_{ i }   {  left[i]  }  ==>  ',   end=''   )
                            left_for_NaN[i]          = left[i]
                            left[i]  =              ( (left[i]+0.001) * new_range )  /  old_range
                            # print(                   left[i],   '   \t',   type( left[i] )   )
                        # temp_list_for_plt.append(   ( i, left[i] )   )
                # plt.plot(  temp_list_for_plt  )
                ''' zostawić to na kiedyś - kogoś zapytać '''

    print( f'\t\t amount of bumps to shrink (counter): ~{  counter  } ')

    print(  zero_cross_list[ -1],  -1  )
    # for start_end   in                (  zero_cross_list[ -1],  len( left )+1  )    :
    print(   f'=L=A=S=T=>\n{  counter  }\t{  zero_cross_list[ -1],  len( left )+1  }'   )    ;    counter += 1

    p_st,  p_en   =   zero_cross_list[ -1],  len( left )+1
    print(     f'     {    p_st     }  {       p_en     }'   )
    # print(   f'  { left[ p_st   ] }  { left[ p_en+1 ] }'   )
    # print(   f'  { left[ p_st+1 ] }  { left[ p_en   ] }'   )
    ''' now: out of range '''

    # per2check =left[   zero_cross_list[ -1]    :  len( left )+1  ]
    per2check =  left[   zero_cross_list[ -1]+1  :                 ] # bo to to samo ;D
    print(  per2check      )
    # print(  per2check[-1]  )    ;    print(  left[-5: ]  )
    print(  per2check[-1]  ==  left[-1: ]  )
    # print(   f'  mean_{  mean( per2check )  }   sum_{  sum( per2check )  }   len_{  len( per2check )  }')
    # print(   f'  sum / len = {                         sum( per2check )   /         len( per2check )  }')

    for i in range(  len(left)+1  ):
        if i in range(   zero_cross_list[ -1]+1,   len( left )   ):
            # print(   f'\nNoNo_{ i }')
            # print(   f'  mean_{  mean( per2check )  }   sum_{  sum( per2check )  }   len_{  len( per2check )  }')
            if       abs( max( per2check ) )  >=  THRESHOLD    \
                or   abs( min( per2check ) )  >=  THRESHOLD:
                # print(   f'  mean_{  mean( per2check )  }   sum_{  sum( per2check )  }   len_{  len( per2check )  }')

                if    max( per2check ) >  0:
                    old_range = max( per2check )
                    new_range =     THRESHOLD - ADDITIONAL_OFFSET

                    # print(   f'no_{ i }   {  left[i]  }  ==>  ',   end=''   )
                    left_for_NaN[i]          = left[i]
                    left[i]  =              ( (left[i]+0.001) * new_range )  /  old_range
                    # print(                   left[i],   '   \t',   type( left[i] )   )

                if    min( per2check ) <  0:
                    old_range = min( per2check )
                    new_range =  -( THRESHOLD - ADDITIONAL_OFFSET )

                    # print(   f'no_{ i }   {  left[i]  }  ==>  ',   end=''   )
                    left_for_NaN[i]          = left[i]
                    left[i]  =              ( (left[i]+0.001) * new_range )  /  old_range
                    # print(                   left[i],   '   \t',   type( left[i] )   )


    def cut_off_above_threshold_for_plt( number ):
        if   abs(number)  >=  THRESHOLD*1.05:
            return number
        else:
            return None
    # left_orig_cut = []
    # for i in left_orig_cut:
    #     left_orig_cut.append(  cut_off_above_threshold_for_plt(  left_orig[i]  )  )
    #     # for j in left_orig:
    #     #     left_orig_cut.append(  cut_off_above_threshold_for_plt(  j  )  )
    # # left_orig_cut = left_orig.copy()
    ''' czemu to nie działa? Zapytać kogoś kiedyś. '''
    discriminator = lambda x: cut_off_above_threshold_for_plt( x )
    left_orig_cut = list(  map(  discriminator,  left_orig  )  )
    # print(  left_orig_cut  )

    # old method
    # # # # df2 = df[0].apply(   lambda  x :   cut_off_above_threshold_for_plt(x)   )
    # # # # print(         df2          )
    ''' 485    20899.0
        486        NaN '''

    org = oryginalny = 8
    ort = org_tło  = org + 1

    orW = waves_to_deform_Nan = org - 4
    # orW = waves_to_deform_Nan = 0.1

    orc = oryg_cut = orW + 12

    zm  = zmieniony = 3.6
    # zm  = zmieniony = 0.1
    zmt = zmieniony_tło   = zm + 2
    zmf = zmieniony_przód = zm + 2

    # # plt.plot(   left_orig    ,   lw=ort,   alpha= 1 ,   c='black'          ,  label='_nolegend_'               )
    # plt.plot(   left_orig    ,   lw=ort,   alpha= 1 ,   c=( 1 , .6 ,  0 )  ,  label='_nolegend_'               )
    plt.plot(   left_orig    ,   lw=org,   alpha= 1 ,   c=( 1 , .75,  0 )  ,  label=' channel    R or L'          )

    # plt.plot(   left_orig_cut,   lw=orc,   alpha= .6,   c='w'              ,  label='   cut off risk(of cut)'  )
    plt.plot(   left_for_NaN ,   lw=orW,   alpha= 1 ,   c=(   1,  0,  0 )  ,  label=' waves to deform'         )

    # plt.plot(   left         ,   lw=zmt,   alpha= .5,   c='w'              ,  label='_nolegend_'               )
    plt.plot(   left         ,   lw=zm ,   alpha= 1 ,   c='black'          ,  label=' channel    R or L  modified'   )
    # plt.plot(   left         ,   lw=zm ,   alpha= 1 ,   c=( 0.7, .9, 0.1)  ,  label=' channel modified'   )
    # plt.plot(   left         ,   lw=zmf,   alpha= .5,   c=(  .8,  1,  .5)  ,  label='_nolegend_'               )

    # plt.plot(   right        ,   lw= .1,   alpha= 1 ,   c=(   0,  0,  1 )  ,  label=' channel right'           )
    #
    # plt.plot(   left_orig_cut,   lw=orc,   alpha= .1,   c=(   0,  0,  0 )  ,  label='   cut off risk(of cut)'  )

    # label the axes
    plt.ylabel(  "Amplitude"  )
    plt.xlabel(    "Time"     )
    # set the title
    plt.title(   "Sample Wav"  )
    plt.title(  f"{ f_name }",   fontsize=6   )

    plt.legend(   loc=0,   fontsize=6   )
    # repair anti-design

    plt.tight_layout()
    # print(   f'\n\t\tplt.tight_layout()\t\tsize_{  get_size(plt.tight_layout())  } [bytes]'   )
    ''' 		plt.tight_layout()		size_16 [bytes] '''

    # from  TheOnlyTime_WORKING  import  TheOnlyTime;   from  datetime  import  datetime
    # plt.savefig(   '%s zapisaneAutomatyczniePycharmem .png'
    #                 %TheOnlyTime( datetime.now() ),
    #                 transparent=False,   bbox_inches='tight',   dpi=300   )

    # display the plot
    plt.show()

    # print(   f'\n\t\tplt.show()\t\t\t\tsize_{      get_size(plt.show()        )  } [bytes]'   )
    ''' 		plt.show()				size_16 [bytes] '''
    # print(   get_size(plt   )
    ''' TypeError: iteration over a 0-d array '''

    return left

"""
⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹
⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸

                                  P R O C E S S

⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹
⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸⡏⠉⢹⣇⣀⣸                                    """


def process_each_Channel(   channel:Tuple   )   ->   Tuple   :
    # print(        list( item )     )
    print(   f'\n---> {  len( list( channel ) )  }'   )
    # shrink = deamplify_gently_parts_of_channel_by_threshold
    channel_shrunk = deamplify_gently_parts_of_channel_by_threshold(  list( channel )  )
    # print(   channel_shrunk,   type( channel_shrunk ),   len( channel_shrunk )   )

    print(                             max( channel_shrunk ),    abs( min( channel_shrunk ) )    )
    '''                                     19999.00097040128              19999.00097040128         '''
    old_range_for_amplify  =  max(     max( channel_shrunk ),    abs( min( channel_shrunk ) )    )
    new_range_for_amplify  =  32_767 - 1
    ''' byt maybe iy is better to set it for   one dB from the TOP   which is: '''
    # new_range_for_amplify  =  29_204
    new_range_for_amplify  =  30_000

    print(   )
    print(     f'len_{  len(channel_shrunk)  }\t\twith floats\t\tsize_{  get_size(channel_shrunk)  } [bytes]'   )
    for i in   range(  len( channel_shrunk )  ):
        # print(   f'~~{  type(channel_shrunk[i])  }  \t{  channel_shrunk[i]  }'   ) # ~~<class 'numpy.float64'>	19999.00066937778
        channel_shrunk[i]  =   np.int16(    ( (channel_shrunk[i]+0.001) * new_range_for_amplify )    \
                                                                        / old_range_for_amplify      )
        # print(   f'~~{  type(channel_shrunk[i])  }  \t{  channel_shrunk[i]  }\n' ) # ~~<class 'numpy.int16'>	32767
    print(     f'len_{  len(channel_shrunk)  }\t\tonly ints\t\tsize_{    get_size(channel_shrunk)  } [bytes]'   )
    # shru = channel_shrunk
    # print(   f'{  type(     shru     )  }\t\tlen_{  len(     shru     )  }\t\tsize_{  get_size(     shru     )  } [bytes]'   )

    ''' len_____1_886					with floats		size_____68_972 [bytes]              '''
    ''' len_____1_886					only ints		size_____66_116 [bytes] - - - - both the same <= this is linked/referenced '''

    ''' len____44_100 = 1 second		with floats		size__1_808_196 [bytes]		threshold =      0.1  ->  30_000 '''
    ''' len____44_100 = 1 second		with floats		size__1_570_758 [bytes]		threshold = 20_000 '''
    ''' len____44_100 = 1 second		with floats		size__1_798_914 [bytes]		threshold =  2_000 '''
    ''' len____44_100 = 1 second		only ints		size__1_543_608 [bytes]						   '''

    ''' len_2_646_000 = 1 minute		with floats		size_92_635_582 [bytes]		threshold =  20_000 '''
    ''' len_2_646_000 = 1 minute		only ints		size_92_610_112 [bytes]		threshold =  20_000 '''


    ''' with floats		len_2_647_739		size_94_651_976 [bytes] ~= ~1 minuta   threshold =  2_000 '''
    ''' only ints		len_2_647_739		size_92_670_974 [bytes] ~= ~1 minuta   threshold =  2_000 '''
    ''' should be               2_646_000                                              '''
    # print(  f' % % % { 44_100 / 2_647_739 } %    { 2_647_739 / 44_100 }  => seconds in minutes (?)'   )
    '''  % % % 0.01665572022015765 %    60.03943310657596  => seconds in minutes (?) '''

    return    tuple( channel_shrunk )



"""
⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤
⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛

                            r e a d   a u d i o

⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤
⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛⠶⣤⠶⠛                                            """

# read audio samples
# f_name = r"200503nie2135 wav [ [], [], [], [] ] WORKING .py _ 500smpl (1 88.2 sekundy) .wav"
f_name = r"200506śro1618 500smpl NaPotrzebyObrazków .wav"
# f_name = r"200503nie2135 wav [ [], [], [], [] ] WORKING .py _ 1min ((( 1709115384  ))) unKnownWawe Format Przeklejone .wav"
input_data = read(  f_name  )
# print(  input_data[0]            ) # 44100 ## częstotliwość próbkowania
audio = input_data[1]
# print(  input_data               )
# print(  input_data.__str__()     )
''' (44100, array(  [  [ 32369, -32507],
                       [  1968,  -2102],
                       [  1002,  -1285],
                       [   563,   -741],
                       [   323,   -430],
                       [   169,   -223],
                       [    57,    -77],
                       [     7,     -9],
                       [     0,      0]  ],   dtype=int16  )  ) '''
# print(   dir(  input_data  )           )
# print(       input_data.__hash__()   )
''' TypeError: unhashable type: 'numpy.ndarray' '''

# print(  0b1111111111111111  ) # 65535
# print(  0b111111111111111   ) # 32767
'''   it seems like  max_min_values_for_wave_int16 are    32767
                                                         -32768   '''

# audio_L_R   =   [   zip(  *input_data[1]  )   ]
# print(    len( audio_L_R )   ) # 1
# audio_L_R   =       zip(  *input_data[1]  )
# print(   type( audio_L_R )   )
''' <class 'zip'> '''
# print(         audio_L_R     )
''' <zip object at 0x000000000F2F96C8> '''
# print(        *audio_L_R     )
''' produce two tuples '''


# print(  audio  )
''' [[ -3705  -4230]
     [ -2955  -3804]
     [ -2116  -3270]
     ...             '''
# left, right   =    zip(  *input_data[1]  )
# print(   len( left  )   ) # 500
# print(        left      )
''' (-3705, -2955, -2116, ...                '''
# left   =   list( left )
''' [-3705, -2955, -2116, ...                '''
# print(   len( right )   ) # 500
# print(        right     )
''' (-4230, -3804, -3270, ...                '''
# right  =   list( right )
''' [-4230, -3804, -3270, ...                '''
# print(   f' len( left ):  {  len( left )  }     len( right ):  {  len( right )  }    ',   end=''   )
# print(   f'{  type( left[5] )  }  {  left[5]  }')


# print(    *zip(  *input_data[1]  )   ,sep='    =[=]=[=]=[=]=[=]=[=]=[=]=[=]=    '   )
''' prints two tuples of lengths == length of wave  '''
L, R   =  zip(  *input_data[1]  )

# L = process_each_Channel( L )
# print(   type(L),   len(L),   L[ -5:  ],   sep='\t\t'   )
''' <class 'list'>		44100		[11273, 3865, 14353, 32734, 31546] '''
# R = process_each_Channel( R )
# print(   type(R),   len(R),   R[ -5:  ],   sep='\t\t'   )
''' <class 'list'>		44100		[-1456, -2311, -899, 20776, 32758] '''
print(     f'len_{  len(R)  }\t\tsome_param\t\tsize_{    get_size(R)  } [bytes]'   )
''' len____44_100 = 1 second		'only~floats'	<class 'list'>		size__1_808_196 [bytes]		threshold = 0.1  ->  30_000 '''
''' len____44_100 = 1 second		'only~floats'	<class 'tuple'>		size__1_499_448 [bytes]		threshold = 0.1  ->  30_000 '''


''' 
total   = 3800
seconds = total % 60
total   = total - seconds
hours   = total / 3600
total   = total - (hours * 3600)
mins    = total / 60
'''



number_of_seconds =  len(R)  /  input_data[0]
def secondsToStr( t ):
    return    "%02dh%02d'%02d.%03d''" \
            % reduce(   lambda ll, b :   divmod( ll[0], b )  +  ll[1: ]
                                       , [  (t*1000,),  1000, 60, 60  ]   )
audio_length = secondsToStr(   len(R)  /  input_data[0]   )
print(   f'len(seconds):\t{number_of_seconds}\n\t\t\t  ≈ {   round( number_of_seconds, 3 )  }\n\t\t\t  = {  audio_length  }'   )




final_tuple: Tuple[List]   =    tuple( [  *zip(   process_each_Channel( L )
                                                , process_each_Channel( R )   )   ] )
print(               len(  final_tuple  ),   'Hz   the same as at the beginning ='   )
print(   str( int(   len(  final_tuple  )  )
          ==  int(   input_data[0]         ) )*5   )
# print(   final_tuple   )


x =  (  input_data[0], np.array( final_tuple , dtype=np.int16)  )
# print( x )
from numpy import save
# np.save(   'sajdfgasfasfj.wav', x, allow_pickle=True, fix_imports=False   )
''' not working '''


# import wave
# w = wave.open(  r"WavFile short\200503nie2135 wav [ [], [], [], [] ] WORKING .py _ 40smpl .wav"
#               , 'r'  )
# # for i in range(w.getnframes()):
# #     frame = w.readframes(i)
# #     print( frame )
''' b''
    b'\x1f\xf2M\xf0'
    b'\xd3\x11\r\x10\x9c5\xf97'
... ... ... 
    b'n\xe8\xe2\xd7\xddH`>\x8ed?Rq~\x05\x81\xb0\x07\xca\xf7\xea\x03\xfb\xfa3\x02\x1b\xfdC\x01R\xfe'
    b'\xa9\x00!\xff9\x00\xb3\xff\x07\x00\xf7\xff\x00\x00\x00\x00'
    b'' '''


# from scipy.io import wavfile
# fs, data = wavfile.read(r"WavFile short\200503nie2135 wav [ [], [], [], [] ] WORKING .py _ 40smpl .wav")
# print(  fs  ) # 44100
# print( data )
''' [  [ -3553  -4019]
       [  1968  -2102]
       [  1002  -1285]
       [   563   -741]
       [   323   -430]
       [   169   -223]
       [    57    -77]
       [     7     -9]
       [     0      0]  ] '''


# import wave, struct
# waveFile = wave.open(r"WavFile short\200503nie2135 wav [ [], [], [], [] ] WORKING .py _ 40smpl .wav", 'r')
# length = waveFile.getnframes()
# for i in range(0,length):
#     waveData = waveFile.readframes(1)
#     data = struct.unpack("<h", waveData)
#     print(int(data[0]))
''' podobne do read() - lecz z błędem '''


# import sys
# from wavefile import WaveReader, WaveWriter
#
# with WaveReader(sys.argv[1]) as r :
#     with WaveWriter(
#             'output.wav',
#             channels=r.channels,
#             samplerate=r.samplerate,
#             ) as w :
#
#         # Just to set the metadata
#         w.metadata.title = r.metadata.title + " II"
#         w.metadata.artist = r.metadata.artist
#
#         # This is the prodessing loop
#         for data in r.read_iter(size=512) :
#             data[1] *= .8     # lower volume on the second channel
#             w.write(data)

import scipy.io.wavfile
from scipy.io.wavfile import write
samplerate = input_data[0]
# fs = 100    ;    t  =   np.linspace(   0.,   1.,  samplerate   )
# amplitude = np.iinfo(  np.int16  ).max
# data   =   amplitude * np.sin(  2. * np.pi * fs * t  )
data   =   np.array( final_tuple )
output_f_name   =  f"{  f_name[ :-5]  } "                             \
                   f"len_{  audio_length  }"                          \
                   f" _shrunkFrom{  THRESHOLD                      }" \
                             f"to{  THRESHOLD - ADDITIONAL_OFFSET  }" \
                   f"_bumpsShrunkinfLastChannel{ counter }±2.wav"
write(   output_f_name,   samplerate,   data   )




"""
⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤
⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛
⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤
⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛
⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤⠶⠶⣤⣤
⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛⠶⠶⠛⠛ """

# print(  get_size(  deamplify_gently_parts_of_channel_by_threshold(  left  )  )  )
''' 66_116 bytes   if np.int16
    68_720 bytes   if int & float '''
# print(  get_size(  left_for_NaN  )  )
''' 27_860 bytes   if None 
    27 868 bytes   if np.NaN '''
# L = deamplify_gently_parts_of_channel_by_threshold(  left  )
# print(   type(L),   '  \t',   L,   ' \tsize:',   sys.getsizeof(L),   ' bytes'   )
''' 17_080 bytes   if np.int16
    17_080 bytes   if np.float64 '''
# for elem in   L[ -250 : -220 ]  :
#     print(   type(    elem ),   '\t   ',       elem ,   ' \tsize:',   sys.getsizeof(    elem ),   ' bytes'   )
#     print(   type(int(elem)),   '\t   ',   int(elem),   ' \tsize:',   sys.getsizeof(int(elem)),   ' bytes'   )
''' <class 'float'>   	        1539.719695461553  	size: 24  bytes
    <class 'numpy.int16'> 	    1539  	            size: 26  bytes
    <class 'int'> 	            1539  	            size: 28  bytes
    <class 'numpy.float64'> 	1539.719695461553  	size: 32  bytes '''
# print(   get_size( np.float64( 1539.719695461553 ) )   )